#!/usr/bin/env python3
import logging
import os
from subprocess import call, DEVNULL
from os import path
from json import load as load_json
from shutil import rmtree
from sys import argv

DEFAULT_PROJECT_FILE_NAME = 'project.json'

NOT_DOWNLOADED_LIBRARIES = []

LIBRARIES_TO_DOWNLOAD = set()
DOWNLOADED_LIBRARIES = set()

LOGGER: logging.Logger


class VT100Formatter(logging.Formatter):

    green = "\x1b[32;20m"
    yellow = "\x1b[33;20m"
    red = "\x1b[31;20m"
    reset = "\x1b[0m"
    format = "%(asctime)s [%(name)s][%(levelname)s] %(message)s"

    FORMATS = {
        logging.INFO: green + format + reset,
        logging.WARNING: yellow + format + reset,
        logging.ERROR: red + format + reset,
    }

    def format(self, record):
        log_fmt = self.FORMATS.get(record.levelno)
        formatter = logging.Formatter(log_fmt)
        return formatter.format(record)


def initialize_logging(name):
    global LOGGER
    LOGGER = logging.getLogger(name)
    LOGGER.setLevel(logging.INFO)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    ch.setFormatter(VT100Formatter())
    LOGGER.addHandler(ch)


def I(text):
    LOGGER.info(text)


def W(text):
    LOGGER.warning(text)


def E(text):
    LOGGER.error(text)


def repository_path(dependency):
    return f"git@github.com:grzegorz-grzeda/{dependency}.git"


def get_project_file_path(project_file_directory):
    return path.join(project_file_directory, DEFAULT_PROJECT_FILE_NAME)


def fetch_project_file(project_file_path):
    with open(project_file_path) as project_file:
        return load_json(project_file)


def get_libraries_path(project, project_file_directory):
    library_path = path.dirname(get_project_file_path(project_file_directory))
    library_name = 'libraries'
    if 'libraries-path' in project:
        library_name = project['libraries-path']
    return path.join(library_path, library_name)


def get_libraries(project):
    return set(project['libraries'])


def clone_library(library, destination_path):
    I(f"Cloning '{library}'")
    call(f'git clone {repository_path(library)} {destination_path}',
         cwd=os.getcwd(), shell=True, stdout=DEVNULL, stderr=DEVNULL)


def generate_cmake_file(libraries_path: str):
    entries = [
        f'add_subdirectory(${{CMAKE_CURRENT_SOURCE_DIR}}/{library})\n' for library in DOWNLOADED_LIBRARIES]
    entries.insert(
        0, '# This file was auto-generated by embuild. DO NOT EDIT!\n')
    cmake_file_path = path.join(libraries_path, 'CMakeLists.txt')
    I(f"Generating {cmake_file_path}")
    with open(cmake_file_path, 'w') as cmake_file:
        cmake_file.writelines(entries)


def load_project():
    project_file_directory = os.getcwd()
    if len(argv) > 1:
        parameter = argv[1]
        if path.isdir(parameter):
            project_file_directory = parameter
            project = fetch_project_file(get_project_file_path(parameter))
        else:
            project_file_directory = path.abspath(path.dirname(parameter))
            project = fetch_project_file(path.abspath(parameter))
    else:
        project = fetch_project_file(
            get_project_file_path(project_file_directory))
    return project, project_file_directory


def clean_libraries_directory(libraries_path):
    I(f"Cleaning '{libraries_path}'")
    rmtree(libraries_path, ignore_errors=True)


def main():
    initialize_logging('embuild')
    try:
        project, project_file_directory = load_project()
        libraries_path = get_libraries_path(project, project_file_directory)
        clean_libraries_directory(libraries_path)

        while True:
            libraries_to_download_from_project = get_libraries(project)
            libraries_to_download = list(
                set(libraries_to_download_from_project) - DOWNLOADED_LIBRARIES)
            if len(libraries_to_download) == 0:
                break
            for library in libraries_to_download:
                destination_path = path.join(libraries_path, library)
                clone_library(library, destination_path)
                DOWNLOADED_LIBRARIES.add(library)
            for library in libraries_to_download:
                destination_path = path.join(libraries_path, library)
                try:
                    project = fetch_project_file(
                        get_project_file_path(destination_path))
                except Exception:
                    continue
        if DOWNLOADED_LIBRARIES:
            generate_cmake_file(libraries_path)
    except Exception as e:
        E(e)


if __name__ == "__main__":
    main()
