#!/usr/bin/env python3
import logging
import os
from subprocess import call, DEVNULL
from os import path
from json import load as load_json
from shutil import rmtree

DEFAULT_PROJECT_FILE_NAME = 'project.json'

NOT_DOWNLOADED_LIBRARIES = []

LIBRARIES_TO_DOWNLOAD = set()
DOWNLOADED_LIBRARIES = set()

LOGGER: logging.Logger


class VT100Formatter(logging.Formatter):

    green = "\x1b[32;20m"
    yellow = "\x1b[33;20m"
    red = "\x1b[31;20m"
    reset = "\x1b[0m"
    format = "%(asctime)s [%(name)s][%(levelname)s] %(message)s"

    FORMATS = {
        logging.INFO: green + format + reset,
        logging.WARNING: yellow + format + reset,
        logging.ERROR: red + format + reset,
    }

    def format(self, record):
        log_fmt = self.FORMATS.get(record.levelno)
        formatter = logging.Formatter(log_fmt)
        return formatter.format(record)


def initialize_logging(name):
    global LOGGER
    LOGGER = logging.getLogger(name)
    LOGGER.setLevel(logging.INFO)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    ch.setFormatter(VT100Formatter())
    LOGGER.addHandler(ch)


def I(text):
    LOGGER.info(text)


def W(text):
    LOGGER.warning(text)


def E(text):
    LOGGER.error(text)


def repository_path(dependency):
    return f"git@github.com:grzegorz-grzeda/{dependency}.git"


def get_project_file_path(project_file_directory):
    return path.join(project_file_directory, DEFAULT_PROJECT_FILE_NAME)


def get_root_project_file_path():
    return get_project_file_path(os.getcwd())


def fetch_project_file(project_file_path):
    with open(project_file_path) as project_file:
        return load_json(project_file)


def get_libraries_path(project):
    library_path = path.dirname(get_root_project_file_path())
    library_name = 'libraries'
    if 'libraries-path' in project:
        library_name = project['libraries-path']
    return path.join(library_path, library_name)


def get_libraries(project):
    return set(project['libraries'])


def clone_library(library, destination_path):
    I(f"Cloning '{library}'")
    call(f'git clone {repository_path(library)} {destination_path}',
         cwd=os.getcwd(), shell=True)


def generate_cmake_file(libraries_path: str):
    entries = [
        f'add_subdirectory(${{CMAKE_CURRENT_SOURCE_DIR}}/{library})' for library in DOWNLOADED_LIBRARIES]
    entries.insert(
        0, '# This file was auto-generated by embuild. DO NOT EDIT!')
    content = '\n'.join(entries)
    cmake_file_path = path.join(libraries_path, 'CMakeLists.txt')
    with open(cmake_file_path, 'w') as cmake_file:
        cmake_file.writelines(content)


def main():
    initialize_logging('embuild')
    try:
        project = fetch_project_file(get_root_project_file_path())
        libraries_path = get_libraries_path(project)
        rmtree(get_libraries_path(project), ignore_errors=True)

        while True:
            libraries_to_download_from_project = get_libraries(project)
            libraries_to_download = list(
                set(libraries_to_download_from_project) - DOWNLOADED_LIBRARIES)
            if len(libraries_to_download) == 0:
                break
            for library in libraries_to_download:
                destination_path = path.join(libraries_path, library)
                clone_library(library, destination_path)
                DOWNLOADED_LIBRARIES.add(library)
            for library in libraries_to_download:
                destination_path = path.join(libraries_path, library)
                try:
                    project = fetch_project_file(
                        get_project_file_path(destination_path))
                except Exception:
                    continue
        if DOWNLOADED_LIBRARIES:
            generate_cmake_file(libraries_path)
    except Exception as e:
        E(e)


if __name__ == "__main__":
    main()
