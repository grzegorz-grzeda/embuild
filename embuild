#!/usr/bin/env python3
import logging
import os
from subprocess import call, DEVNULL
from os import path
from json import load as load_json
from shutil import rmtree
from sys import argv

DEFAULT_PROJECT_FILE_NAME = 'project.json'

LOGGER: logging.Logger

ASSETS = {'libraries', 'packages'}
CMAKE_FOR_ASSETS = {'libraries'}


class VT100Formatter(logging.Formatter):

    green = "\x1b[32;20m"
    yellow = "\x1b[33;20m"
    red = "\x1b[31;20m"
    reset = "\x1b[0m"
    format = "%(asctime)s [%(name)s][%(levelname)s] %(message)s"

    FORMATS = {
        logging.DEBUG: green + format + reset,
        logging.INFO: green + format + reset,
        logging.WARNING: yellow + format + reset,
        logging.ERROR: red + format + reset,
    }

    def format(self, record):
        log_fmt = self.FORMATS.get(record.levelno)
        formatter = logging.Formatter(log_fmt)
        return formatter.format(record)


def initialize_logging(name: str):
    global LOGGER
    LOGGER = logging.getLogger(name)
    LOGGER.setLevel(logging.DEBUG)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    ch.setFormatter(VT100Formatter())
    LOGGER.addHandler(ch)


def D(text: str) -> None:
    LOGGER.debug(text)


def I(text: str) -> None:
    LOGGER.info(text)


def W(text: str) -> None:
    LOGGER.warning(text)


def E(text: str) -> None:
    LOGGER.error(text)


def repository_path(dependency: str) -> str:
    if ".git" in dependency:
        return dependency
    else:
        return f"git@github.com:grzegorz-grzeda/{dependency}.git"


def get_project_file_path(project_file_directory: str) -> str:
    return path.join(project_file_directory, DEFAULT_PROJECT_FILE_NAME)


def fetch_project_file(project_file_path: str) -> dict:
    project = {}
    with open(project_file_path) as project_file:
        project = load_json(project_file)
    if not "name" in project:
        project['name'] = path.basename(path.dirname(project_file_path))
    return project


def get_assets_from_project(project: dict, project_assets_name: str) -> set:
    return set(project[project_assets_name])


def get_assets_destination_path(project: dict, project_file_directory: str, project_assets_name: str) -> str:
    package_name = project_assets_name
    if f'{project_assets_name}-path' in project:
        package_name = project[f'{project_assets_name}-path']
    return path.join(project_file_directory, package_name)


def clone_asset(asset: str, destination_path: str) -> None:
    D(f"Cloning '{asset}' into '{destination_path}'")
    call(f'git clone {repository_path(asset)} {destination_path}',
         cwd=os.getcwd(), shell=True, stdout=DEVNULL, stderr=DEVNULL)


def execute_preconditions(project: dict, destination_path: str) -> None:
    D(f"Executing preconditions if exist")
    if 'preconditions' in project:
        for precondition in project['preconditions']:
            call(precondition, cwd=destination_path,
                 shell=True, stdout=DEVNULL, stderr=DEVNULL)


def get_asset_name_from_asset_declaration(asset_declaration: str) -> str:
    asset_name = asset_declaration.split(
        '/')[-1] if '/' in asset_declaration else asset_declaration
    asset_name = asset_name.replace('.git', '')
    return asset_name


def generate_cmake_file(assets_path: str, assets: list) -> None:
    entries = [
        f'add_subdirectory(${{CMAKE_CURRENT_SOURCE_DIR}}/{get_asset_name_from_asset_declaration(asset)})\n' for asset in assets]
    entries.insert(
        0, '# This file was auto-generated by embuild. DO NOT EDIT!\n')
    cmake_file_path = path.join(assets_path, 'CMakeLists.txt')
    D(f"Generating {cmake_file_path}")
    with open(cmake_file_path, 'w') as cmake_file:
        cmake_file.writelines(entries)


def load_project() -> tuple:
    project_file_directory = os.getcwd()
    if len(argv) > 1:
        parameter = argv[1]
        if path.isdir(parameter):
            project_file_directory = parameter
            project = fetch_project_file(get_project_file_path(parameter))
        else:
            project_file_directory = path.abspath(path.dirname(parameter))
            project = fetch_project_file(path.abspath(parameter))
    else:
        project = fetch_project_file(
            get_project_file_path(project_file_directory))
    return project, project_file_directory


def clean_destination_directory(destination_path: str) -> None:
    D(f"Cleaning '{destination_path}'")
    rmtree(destination_path, ignore_errors=True)


def download_assets(project: str, assets_path: str, project_assets_name: str, should_generate_cmake: bool) -> None:
    downloaded_assets = set()
    while True:
        assets_to_download_from_project = get_assets_from_project(
            project, project_assets_name)
        assets_to_download = list(
            set(assets_to_download_from_project) - downloaded_assets)
        if len(assets_to_download) == 0:
            break
        D(f"Downloading {project_assets_name} for {project['name']}")
        for asset in assets_to_download:
            asset_name = get_asset_name_from_asset_declaration(asset)
            destination_path = path.join(assets_path, asset_name)
            clone_asset(asset, destination_path)
            downloaded_assets.add(asset)
        for asset in assets_to_download:
            destination_path = path.join(assets_path, asset)
            try:
                project = fetch_project_file(
                    get_project_file_path(destination_path))
                execute_preconditions(project, destination_path)
            except Exception:
                continue
    if should_generate_cmake and downloaded_assets:
        generate_cmake_file(assets_path, downloaded_assets)


def main():
    initialize_logging('embuild')
    try:
        D("Loading project file")
        project, project_file_directory = load_project()
        assets_to_handle = {}
        for asset in ASSETS:
            D(f"Cleaning {asset}")
            assets_path = get_assets_destination_path(
                project, project_file_directory, asset)
            clean_destination_directory(assets_path)
            assets_to_handle[asset] = assets_path
        for asset, asset_path in assets_to_handle.items():
            D(f"Downloading {asset}")
            download_assets(project, asset_path, asset,
                            asset in CMAKE_FOR_ASSETS)
    except Exception as e:
        E(e)
    finally:
        D("Done")


if __name__ == "__main__":
    main()
